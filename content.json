{"meta":{"title":"Mr.chen的blog","subtitle":null,"description":null,"author":"Mr.chen","url":"https://blog.clz.cloud","root":"/"},"pages":[{"title":"","date":"2022-03-28T08:51:04.753Z","updated":"2022-03-28T08:51:04.753Z","comments":true,"path":"404.html","permalink":"https://blog.clz.cloud/404.html","excerpt":"","text":""},{"title":"","date":"2022-03-28T08:51:04.756Z","updated":"2022-03-28T08:51:04.756Z","comments":true,"path":"googlea28ffae42df3c06e.html","permalink":"https://blog.clz.cloud/googlea28ffae42df3c06e.html","excerpt":"","text":"google-site-verification: googlea28ffae42df3c06e.html"},{"title":"","date":"2022-03-28T08:51:04.756Z","updated":"2022-03-28T08:51:04.756Z","comments":true,"path":"baidu_verify_XeWR9kzXZ9.html","permalink":"https://blog.clz.cloud/baidu_verify_XeWR9kzXZ9.html","excerpt":"","text":"XeWR9kzXZ9"},{"title":"","date":"2022-04-10T13:11:02.688Z","updated":"2022-04-10T13:11:02.688Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://blog.clz.cloud/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"about","date":"2019-08-11T18:28:20.000Z","updated":"2022-03-28T08:51:04.756Z","comments":false,"path":"about/index.html","permalink":"https://blog.clz.cloud/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-02T04:33:16.000Z","updated":"2022-03-28T08:51:04.756Z","comments":false,"path":"categories/index.html","permalink":"https://blog.clz.cloud/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-11T18:28:19.000Z","updated":"2022-03-28T08:51:04.757Z","comments":false,"path":"tags/index.html","permalink":"https://blog.clz.cloud/tags/index.html","excerpt":"","text":""},{"title":"有事请留言","date":"2019-08-12T07:52:05.000Z","updated":"2022-03-28T08:51:04.757Z","comments":true,"path":"message/index.html","permalink":"https://blog.clz.cloud/message/index.html","excerpt":"","text":"有事请留言"}],"posts":[{"title":"GO的协程","slug":"GO的协程","date":"2022-04-10T12:20:00.000Z","updated":"2022-04-10T12:20:47.816Z","comments":true,"path":"GO的协程.html","link":"","permalink":"https://blog.clz.cloud/GO的协程.html","excerpt":"","text":"数据类型概念 值类型和引用类型 两者的主要区别：拷贝操作和函数传参。值类型的变量存储的是一个内存地址，引用类型的变量实际上是一个内存指针 123456789101112131415161718192021222324252627// 值类型：int、float、bool和string这些类型都属于值类型,// 使用这些类型的变量直接指向存在内存中的值，，值类型的变量的值存储在栈中。当使用等号=将一个变量的值赋给另一个变量时，如 j = i ,实际上是在内存中将 i 的值进行了拷贝。可以通过 &amp;i 获取变量 i 的内存地址。 值拷贝// 引用类型：特指slice、map、channel这三种预定义类型// 引用类型拥有更复杂的存储结构:(1)分配内存 (2)初始化一系列属性等一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置，这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。// 1. 定义了一个数组a，它是值类型，复制给b是copy，当b发生变化后a并不会发生任何变化func main() &#123; a := [...]int&#123;1, 2, 3, 4, 5&#125; b := a b[2] = 100 fmt.Println(a, b)&#125;// [1 2 3 4 5] [1 2 100 4 5]// 2. 使用切片再试一下 (结果是一样的，因为切片a存的不是一个地址，而是一个指针，那么 a 和 b的指针一样了，通过b进行变量的操作，那么实际上影响的还是那个内存地址)func main() &#123; // 大家看到下面是不是迷惑了 // 为什么这个和上面的写法看着都一样呀 // 这就涉及到切片操作了 // 通过字面量创建切片，这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定 a := []int&#123;1, 2, 3, 4, 5&#125; b := a b[2] = 8 fmt.Println(a, b)&#125;// [1 2 8 4 5] [1 2 8 4 5] 2. 数组 arrays 首先声明一个数组对象 12// 因为没有设置一个值，所以默认为0 ， 下面是 声明一个数组变量a， 元素的数据类型是 int， 一共有五个元素var a [5]int 赋值数组内的元素 123456789101112//声明一个int数组，大小为5个, 每个元素默认为0 var a [5]int// 通过索引index的方式设置数组对象中元素的值 // 语法 variableName[index] = value// 需要注意的一点，就是数据类型，要和初始化时制定的数据类型一样才可以a[4] = 200a[3] = 100fmt.Println(\"set: \", a)// result set: [0 0 0 100 200] 动态声明数组 1234567891011121314151617181920// 我们大概有以下集中声明数组的方法// 1. 已知数组长度// 这种方法，只是初始化，但是不带初始化值，也就是里面每个元素都为0vat array [5]int// 即能初始化变量，又带了初始化值var array = [5]int&#123;1, 2, 3, 4, 5&#125;// 可以不用写具体的长度，使用`...`代替var array = [...]int&#123;1, 2, 3, 4, 5&#125;// 简写array := [...]int&#123;1, 2, 3, 4, 5&#125;// 2. 当数组的长度是一个动态的值n的是时候，用上述的方法去初始化数组肯定会报错的，那这时候，我们应该去使用 `make` 函数array := make([]int, n) 3. 切片 slice 一个切片有三部分组成，地址指针、 长度、 容量 123456789// 1. 长度是什么？// 答： 是指可以访问的元素的个数// eg： [1 2 3 4] 这个切片打印出来是这样的,那么这个切片的长度为4， 可以使用len函数去获取到这个值// 2. 容量是什么？// 首先普及一个概念，容量不是指这个切片当前的长度，而是指这个切片可以增长到的长度// 你可以这样理解，都玩过MySQL吧，建表的时候，字符串类型一般用varchar和char// 那这两个字段类型有什么区别呢？ // 你百度以下就知道了，我写下去，，又是一大堆字，懒得写，你就可以大致理解为，切片就类似于 varchar， 声明了一个200长度的字符串类型，唉，我就不放满，就放10个，就是玩，我也可以。 但是char就不行了，10个长度，你不放10个，，肯定报错！ 通过 make() 函数创建切片 12345// 创建一个切片，长度和容量都为10个元素slice := make([]int, 10)// 创建一个切片，制定长度为5， 容量为10slice := make([]int, 5, 10) 通过字面量创建切片 另一种常用的创建切片的方法是使用切片字面量，这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定： 12345678910// 创建一个长度和容量都为3的字符串切片myStr := []string&#123;\"a\", \"b\", \"c\"&#125;// 创建一个整型切片，长度和容量都为5myInt := []int&#123;1, 2, 3, 4, 5&#125;// 创建一个 长度为2 ， 容量为5 的整型切片myInt2 := myInt[0:2]fmt.Print(\"myInt2 len &amp; cap \", len(myInt2), cap(myInt2))// myInt2 len &amp; cap 2 5 nil 和空切片 程序可能需要声明一个值为 nil 的切片（也称nil切片）。只要在声明时不做任何初始化，就会创建一个 nil 切片 1234567891011// 创建nil 整型切片var myNum []int// 创建空的 整型切片// 使用字面量写法myNum := []int&#123;&#125;// 使用make 写法myNum := make([]int, 0) 4. map 声明map类型的变量 语法： make(map[key-type]value-type) 1234567// 1. 使用make 进行map数据类型变量的初始化 （引用类型变量需要初始化内存分配地址）m := make(map[String]int)fmt.Println(\"m\", m)// map [ ] 进行map变量的内容赋值 语法：经典的name[key] = value 12m := make(map[string]int)","categories":[{"name":"GO","slug":"GO","permalink":"https://blog.clz.cloud/categories/GO/"}],"tags":[{"name":"c l z","slug":"c-l-z","permalink":"https://blog.clz.cloud/tags/c-l-z/"}],"author":"Mr.chen"},{"title":"Hello World","slug":"hello-world","date":"2022-03-28T08:51:04.754Z","updated":"2022-03-28T08:51:04.754Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://blog.clz.cloud/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"GO数据类型概念","slug":"GO基础","date":"2022-03-23T02:33:42.000Z","updated":"2022-03-29T10:10:48.138Z","comments":true,"path":"GO基础.html","link":"","permalink":"https://blog.clz.cloud/GO基础.html","excerpt":"","text":"数据类型概念 值类型和引用类型 两者的主要区别：拷贝操作和函数传参。值类型的变量存储的是一个内存地址，引用类型的变量实际上是一个内存指针 123456789101112131415161718192021222324252627// 值类型：int、float、bool和string这些类型都属于值类型,// 使用这些类型的变量直接指向存在内存中的值，，值类型的变量的值存储在栈中。当使用等号=将一个变量的值赋给另一个变量时，如 j = i ,实际上是在内存中将 i 的值进行了拷贝。可以通过 &amp;i 获取变量 i 的内存地址。 值拷贝// 引用类型：特指slice、map、channel这三种预定义类型// 引用类型拥有更复杂的存储结构:(1)分配内存 (2)初始化一系列属性等一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置，这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。// 1. 定义了一个数组a，它是值类型，复制给b是copy，当b发生变化后a并不会发生任何变化func main() &#123; a := [...]int&#123;1, 2, 3, 4, 5&#125; b := a b[2] = 100 fmt.Println(a, b)&#125;// [1 2 3 4 5] [1 2 100 4 5]// 2. 使用切片再试一下 (结果是一样的，因为切片a存的不是一个地址，而是一个指针，那么 a 和 b的指针一样了，通过b进行变量的操作，那么实际上影响的还是那个内存地址)func main() &#123; // 大家看到下面是不是迷惑了 // 为什么这个和上面的写法看着都一样呀 // 这就涉及到切片操作了 // 通过字面量创建切片，这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定 a := []int&#123;1, 2, 3, 4, 5&#125; b := a b[2] = 8 fmt.Println(a, b)&#125;// [1 2 8 4 5] [1 2 8 4 5] 2. 数组 arrays 首先声明一个数组对象 12// 因为没有设置一个值，所以默认为0 ， 下面是 声明一个数组变量a， 元素的数据类型是 int， 一共有五个元素var a [5]int 赋值数组内的元素 123456789101112//声明一个int数组，大小为5个, 每个元素默认为0 var a [5]int// 通过索引index的方式设置数组对象中元素的值 // 语法 variableName[index] = value// 需要注意的一点，就是数据类型，要和初始化时制定的数据类型一样才可以a[4] = 200a[3] = 100fmt.Println(\"set: \", a)// result set: [0 0 0 100 200] 动态声明数组 1234567891011121314151617181920// 我们大概有以下集中声明数组的方法// 1. 已知数组长度// 这种方法，只是初始化，但是不带初始化值，也就是里面每个元素都为0vat array [5]int// 即能初始化变量，又带了初始化值var array = [5]int&#123;1, 2, 3, 4, 5&#125;// 可以不用写具体的长度，使用`...`代替var array = [...]int&#123;1, 2, 3, 4, 5&#125;// 简写array := [...]int&#123;1, 2, 3, 4, 5&#125;// 2. 当数组的长度是一个动态的值n的是时候，用上述的方法去初始化数组肯定会报错的，那这时候，我们应该去使用 `make` 函数array := make([]int, n) 3. 切片 slice 一个切片有三部分组成，地址指针、 长度、 容量 123456789// 1. 长度是什么？// 答： 是指可以访问的元素的个数// eg： [1 2 3 4] 这个切片打印出来是这样的,那么这个切片的长度为4， 可以使用len函数去获取到这个值// 2. 容量是什么？// 首先普及一个概念，容量不是指这个切片当前的长度，而是指这个切片可以增长到的长度// 你可以这样理解，都玩过MySQL吧，建表的时候，字符串类型一般用varchar和char// 那这两个字段类型有什么区别呢？ // 你百度以下就知道了，我写下去，，又是一大堆字，懒得写，你就可以大致理解为，切片就类似于 varchar， 声明了一个200长度的字符串类型，唉，我就不放满，就放10个，就是玩，我也可以。 但是char就不行了，10个长度，你不放10个，，肯定报错！ 通过 make() 函数创建切片 12345// 创建一个切片，长度和容量都为10个元素slice := make([]int, 10)// 创建一个切片，制定长度为5， 容量为10slice := make([]int, 5, 10) 通过字面量创建切片 另一种常用的创建切片的方法是使用切片字面量，这种方法和创建数组类似，只是不需要指定[]运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定： 12345678910// 创建一个长度和容量都为3的字符串切片myStr := []string&#123;\"a\", \"b\", \"c\"&#125;// 创建一个整型切片，长度和容量都为5myInt := []int&#123;1, 2, 3, 4, 5&#125;// 创建一个 长度为2 ， 容量为5 的整型切片myInt2 := myInt[0:2]fmt.Print(\"myInt2 len &amp; cap \", len(myInt2), cap(myInt2))// myInt2 len &amp; cap 2 5 nil 和空切片 程序可能需要声明一个值为 nil 的切片（也称nil切片）。只要在声明时不做任何初始化，就会创建一个 nil 切片 1234567891011// 创建nil 整型切片var myNum []int// 创建空的 整型切片// 使用字面量写法myNum := []int&#123;&#125;// 使用make 写法myNum := make([]int, 0) 4. map 声明map类型的变量 语法： make(map[key-type]value-type) 1234567// 1. 使用make 进行map数据类型变量的初始化 （引用类型变量需要初始化内存分配地址）m := make(map[String]int)fmt.Println(\"m\", m)// map [ ] 进行map变量的内容赋值 语法：经典的name[key] = value 12m := make(map[string]int)","categories":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/tags/golang/"},{"name":"go","slug":"go","permalink":"https://blog.clz.cloud/tags/go/"}]},{"title":"flask笔记","slug":"flask笔记","date":"2019-08-10T05:52:50.000Z","updated":"2022-03-28T08:51:04.754Z","comments":true,"path":"flask笔记.html","link":"","permalink":"https://blog.clz.cloud/flask笔记.html","excerpt":"","text":"FLASK 安装先创建一个虚拟环境，并使用pycharm 初始化一个pure python项目 1mkvirtualenv flask_demo -p python3 1pip install flask==0.12.4 flask的简单组成 初始化flask ==》 路由 创建一个flask 应用 12## 创建flask 应用app = Flask(__name__) 路由-限定请求方式 1234567891011@app.route('/')def idnex(): return '这里是首页'##路由-限定请求方式## route 中有个参数methods 是定义请求类型的，只有定义了才能访问，#默认的是开启get的@app.route('/',methods=[\"get\",\"post\"])def idnex(): return '这里是首页' 开启debug模式 1DEBUG = True 在主文件导入配置文件 123456class Config(object) DEBUG = True app.config.from_object(Config)## 最常用的方式是通过对象的方式， 通过导包，将配置文件加载 启动flask 123456app.run(host='localhost',port=8080,debug=true) # flask 内部作为一个基本的web框架，内置http服务器肯定有的。 #运行flask 可以使用 app.run（） # host 服务器启动时绑定的域名 #port 服务器启动时绑定的端口 #debug 是否开启调试模式 简单的flask demo详解在路由中设置变量（传递参数-两种）123456789101112## 使用'&lt; &gt;' 表示变量名，##&lt;int:变量名&gt;表示限制变量的数据类型@app.route(\"/user/&lt;int:userid&gt;\")def user(userid): return \"用户个人中心%s\" % userid\"\"\"限制参数类型int:变量名 #当前路由内容只能是整型float:变量名 #当前路由内容只能是 浮点数path:变量名 #当前路由内容可以是任何内容\"\"\" 正则匹配路由1.首先导入转换器基类 1from werkzeug.routing import BaseConverter 2.自定义转换器 123456class RegexCover(BaseConverter): def __init__(self, map,*args): super(RegexCover,self).__init__(map) ## 正则参数 self.regex = args[0] 3.将自定义的转换器添加到转换器字典中，并指定转换器使用的别名 1app.url_map.converters['regex'] = RegexCover 4.就可以通过正则去获取参数变量了 1234## regex 后面跟一个元组，元祖里面是正则表达式，mobile是变量名@app.route(\"/user/&lt;regex('\\d+'):mobile&gt;\")def user(mobile): return \"用户手机号%s\" % mobile 预定义正则匹配路由可以直接讲正则(regex)写死,然后直接用就行了一般应用场景是 固定类型的正则（验证手机号的合法等等） 1234567891011## 声明一个固定转换器class Mobileter(BaseConverter): regex = \"1[3-9]\\d&#123;9&#125;\" ## 将上面的转化器注册到转化器字典中app.url_map.converters['mobile'] = Mobileter##使用自定义的转换器，@app.route(\"/user/&lt;mobile:mobile&gt;\")def user(mobile): return \"用户手机号%s\" % mobile 系统自带转换器 werkzeug.routing.py 123456789DEFAULT_CONVERTERS = &#123; \"default\": UnicodeConverter, \"string\": UnicodeConverter, \"any\": AnyConverter, \"path\": PathConverter, \"int\": IntegerConverter, \"float\": FloatConverter, \"uuid\": UUIDConverter,&#125; http的请求与响应在flask中导入 request 模块，用request模块去获取客户端提交的数据 常用的属性如下： 属性 说明 类型 data 记录请求的数据，并转换为字符串 * form 记录请求中的表单数据 MultiDict args 记录请求中的查询参数 MultiDict cookies 记录请求中的cookie信息 Dict headers 记录请求中的请求头 EnvironHeaders method 记录请求使用的HTTP方法 GET/POST url 记录请求的URL地址 string files 记录请求上传的文件 * json 记录请求的json数据 json 响应 Flask 默认支持两种响应方式 数据响应： 默认响应html，也可以返回json 页面响应：重定向 url_for 响应的时候，flask也支持自定义响应状态码 响应html文本 12345## 路由@app.route(\"/\")def index(): # [默认支持]响应html文本 return \"&lt;img src='https://palletsprojects.com/logo-large.png'&gt;\" 返回JSON数据 在flask中可以直接使用jsonify 生成一个json的响应 123456789101112from flask import Flask, request, jsonify@app.route(\"/\")def index(): # 也可以响应json格式代码 data = [ &#123;\"id\":1,\"username\":\"liulaoshi\",\"age\":18&#125;, &#123;\"id\":2,\"username\":\"liulaoshi\",\"age\":17&#125;, &#123;\"id\":3,\"username\":\"liulaoshi\",\"age\":16&#125;, &#123;\"id\":4,\"username\":\"liulaoshi\",\"age\":15&#125;, ] return jsonify(data) 重定向 重定向到站外页面 123456from flask import Flask,request,jsonify,redirect@app.route(\"/\")def index(): # 页面跳转响应 return redirect('http://www.baidu.com') 重定向到自己写的视图函数 也可以直接填写自己的url路径 也可以使用url_for 生成指定视图函数所对应url 1234567891011@app.route(\"/user\")def user(): # 页面跳转响应 userid = None return 'userid %s' % userid## 路由@app.route(\"/\")def index(): # 页面跳转响应 return redirect(url_for('user')) ## 这里的user 是上面的user函数 url_for 12345#使用url_for可以实现视图方法之间的内部跳转# url_for(\"视图方法名\")@app.route(\"/login\")def login(): return redirect( url_for(\"index\") ) 重定向到带有参数的视图函数 在url_for 函数中传入参数 1234567891011## 路由传递参数@app.route(\"/user/&lt;userid&gt;\")def user(userid): # 页面跳转响应 return 'userid %s' % userid# 重定向@app.route(\"/\")def index(): # 使用url_for 生成指定视图函数所对应的url return redirect(url_for('user',userid=100)) 自定义状态码 在flask 中，可以很方便的返回自定义状态码，以实现不符合http协议的状态吗，例如：status code :666 123@app.route('/demo4')def demo4(): return '状态码为 666', 400 会话控制实现状态保持的两种方式： 在客户端存储信息使用Cookie本地存储，token[jwt.,auth] 在服务器端存储信息使用Session，redis 设置Cookieflask框架提供了一个make_responce 函数来快速创建响应对象 12345678## 首先实例化一个make_responce对象，传入的参数是响应对象的主体## 去给这个响应对象设置cookies， 传入key，value，过期时间## 最后将这个对象retrun ge给客户端@app.route(\"/\")def set_cookie(): resp = make_response('this is set cookie') resp.set_cookie('usename','xiaoming',max_age=3600) return resp 获取Cookie1234@app.route(\"/get\")def get_cookie(): resp = request.cookies.get('username') return resp Session 在服务器段进行状态保存的方案就是Session 注意：Session依赖于Cookie，而且flask中使用session，需要配置SECRET_KEY 选项，否则报错 设置session12345678910111213## 首先设置SECRET_KEY class Config(object): SECRET_KEY = '1231fddfds213'app.config.from_object(Config)## 然后从flask中导入session模块from flask import session## 定义视图函数@app.route(\"/set\")def set(): session['uname'] = 'xiaoming' return 'ok' 获取session12345## 直接使用session.get(ket)这个函数取得存储的session@app.route(\"/get\")def get(): resp = session.get('uname') return res 上下文flask中上下文的分为两种上下文：即语境，语意，在程序中可以理解为在代码执行到某一时刻时，根据之前代码所做的操作以及下文即将要执行的逻辑，可以决定在当前时刻下可以使用到的变量，或者可以完成的事情。 Flask中有两种上下文，请求上下文(request context)和应用上下文(application context)。 Flask中上下文对象：相当于一个容器，保存了 Flask 程序运行过程中的一些信息[变量、函数、类与对象等信息] application 指的就是当你调用app = Flask(__name__)创建的这个对象app； request 指的是每次http请求发生时，WSGI server(比如gunicorn)调用Flask.__call__()之后，在Flask对象内部创建的Request对象； application 表示用于响应WSGI请求的应用本身，request 表示每次http请求； application的生命周期大于request，一个application存活期间，可能发生多次http请求，所以，也就会有多个request 请求上下文对象 request 123Flask的请求上下文，包含请求变量如:method、args、form、values、endpoint、headers、remote_addr都是比较常用的。 例如 ： request.args.get ('user' ) 获取get请求参数 session 1Flask的请求上下文，用于存放用户的会话信息。 应用上下文对象 current_app 1Flask的应用上下文，返回当前app的方法和属性，可以勉强理解为类全局变量。 g 1234 作为Flask 程序全局中的一个临时变量 不同的请求有不同的全局变量g简单来说这个临时变量的生命周期就是一次请求，。 只在当前请求中共享变量 两者区别： 请求上下文：保存了客户端和服务器交互的数据 应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等 请求钩子flask的四种请求钩子（又称网络拦截器） before_first_request 在处理第一个请求之前执行（项目初始化的钩子） 应用场景：开启数据库链接，等等 before_request 在每次请求前执行 如果在某修饰函数中返回了一个响应，视图函数将不再被调用 应用场景： 做jwt 或者auth 权限认证， 如果不通过则返回一个响应对象，这样下面的视图函数就不走了。 after_request 必须接收一个response的参数，是请求执行的视图函数的返回对象 如果没有抛出错误，在每次请求后执行 接受一个参数： 将视图函数的作出的响应对象传入 在此函数中可以对响对象中的值在返回之前做最后一部修改处理 需要将参数中的响应子啊此参数中进行返回 teardown_request 严格来说，没有固定请求的位置，只有请求上下文被pop出栈的时候就会出发这个，所以即使之前有跑出错误都会执行，通俗一点就是当 在视图内部报错之后执行 接受一个参数： 错误信息，如果有相关错误抛出 需要设置flask的配置DEBUG=False，teardown_request才会接受到异常对象。 可以通过request 方法，进行对请求的url及参数或者文件的提取，再进行逻辑判断，从而决定钩子的流程控制及返回值 after_request 必须接收一个response的参数，是请求执行的视图函数的返回对象1234567891011121314## 请求对应的视图函数执行后＝要执行的钩子函数，在返回客户端之前@app.after_requestdef after_request(responce): print('－－－请求执行后需要执行的钩子函数－－－') print('－－－主要作用就是对视图函数返回的值到客户端之前进行再此的修饰－－－') print(responce.data) return responce#路由@app.route(\"/\")def user(): # 页面跳转响应 print('----视图函数-----') return 'ok' teardown_request 当视图中报错时候就会触发teardown请求钩子，必须要一个参数接收异常信息 1234## 在视图内，抛出异常就会执行@app.teardown_requestdef teardown_request(exc): print('exc %s' % exsc ) 异常捕获主动抛出HTTP异常 abort方法 抛出一个给定状态码的HTTPException或者指定响应，列如想要用一个页面未找到异常来终止请求，你可以调用abort(404) 参数： code -HTTP 的错误状态码 12# abort(404)abort(500) 抛出状态码的话，只能抛出HTTP协议的错误状态吗 捕获错误 errorhandler 装饰器 注册一个错误处理程序，当检测到程序抛出指定错误状态吗的时候，就会调用该装饰器所装饰的方法 参数 code_or_exception-HTTP 的错误状态吗或指定异常 例如，统一处理“页面找不到”，状态码为500 ，给用户友好的提示 1234@app.errorhandler(404)def error_404(error): print(error) return \"&lt;img src=https://raw.githubusercontent.com/chenluzhong150394/img/master/1.png &gt;\" 捕获指定异常类型 123@app.errorhandler(ZeroDivisionError)def zero_division_error(e): return '除数不能为0' 实例 1234567891011121314151617181920212223242526272829303132333435from flask import Flaskfrom settings.dev import Config# 创建flask应用app = Flask(__name__)\"\"\"加载配置\"\"\"app.config.from_object(Config)\"\"\"flask中内置了app.errorhander提供给我们捕获异常，实现一些在业务发生错误时的自定义处理。1. 通过http状态码捕获异常信息2. 通过异常类进行异常捕获\"\"\"\"\"\"1. 捕获http异常[在装饰器中写上要捕获的异常状态码也可以是异常类]\"\"\"@app.errorhandler(404)def error_404(e): return \"&lt;h1&gt;您访问的页面失联了！&lt;/h1&gt;\"\"\"\"2. 捕获系统异常或者自定义异常\"\"\"class APIError(Exception): pass@app.route(\"/\")def index(): raise APIError(\"api接口调用参数有误！\") return \"个人中心，视图执行了！！\"@app.errorhandler(APIError)def error_apierror(e): return \"错误: %s\" % eif __name__ == '__main__': app.run(host=\"localhost\",port=8080) Flask-Script扩展安装命令：1pip install flask-script 集成 Flask-Script到flask应用中，创建一个主应用程序，一般我们叫manage.py 配置脚手架使其能通过终端运行项目12345678910111213141516171819202122### 第一步 ，导包from flask_script import Manager### 第二步 初始化manger对象，传入app应用进行绑定manage = Manager(app)### 第三步，就可以使用manage启动运行项目if __name__ == '__main__': manage.run()### 使用终端运行, (main.py 为项目文件)&gt;&gt; python main.py runserver ### 通过 -？ 来获取执行函数的参数&gt;&gt; python main.py runserver -? # 端口和域名不写，默认为127.0.0.1:5000python manage.py runserver# 通过-h设置启动域名，-p设置启动端口python manage.py runserver -h127.0.0.1 -p8080 Flask-Script 可以直接为当前脚本添加新的命令1234567891011#第一步，首先引入Command基类from flask_script import Manager,Command# 第二步 , 自定义命令类，继承Command基类，并将要执行的逻辑放到run方法里面class Hello(Command): \"\"\"run方法里面存放着要执行的逻辑\"\"\" def run(self): print('123')# 第三步，注册自定义命令类并加上别名manage.add_command('hello', Hello() ) 注意，如果有自定义的其他参数传入，需要使用init构造函数导入 Jinja2模板引擎flask中内置的模板语言，设计思想来源与django中的模板引擎,flask 内置的render_template 函数封装了这个模板引擎 要想在flask中使用模板引擎，需要做以下设置 12345678910#首先在创建flask 应用的时候加上 template_folder 参数，指定模板的根目录app = Flask(__name__,template_folder = 'templates')## 默认是在项目的根目录下的## 在视图函数中设置渲染模板设置模板数据from flask import render_template @app.route('/index')def inde(): return render_template('index.html',title='我的flask 项目') 在视图函数中往janja2 模板传入变量 12345678910111213141516### 视图函数@app.route('/index')def inde(): sts = '这也是一个变量' return render_template('index.html',title='我的flask 项目',sts) ## title就是一个变量, sts 也是 ，这是两种方式，前者是传入已经定义好的变量名，后者是直接变量名加上赋值操作一起做， ### 在模板中使用变量## 使用两个花括号来表示变量名 ，， 这种语法叫做** 变量代码块&#123;&#123;&#125;&#125; &#123;&#123; title &#125;&#125;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Jinja2 模板中的变量代码块可以是任何python类型后者对象，只要它能够被python的\\str__魔术方法 或者str() 方法转换成字符串就可以，通俗来说只要能被json的对象都可以。 在模板中怎样注释变量 1&#123;# &#123;&#123; name &#125;&#125; #&#125; jinja2模板内置的变量和函数 就是说你可以在模板中直接访问flask内置的函数和对象 Config 你可以直接在模板中访问flask中的config对象 1&lt;h5&gt;&#123;&#123;config.DEBUG&#125;&#125;&lt;/h5&gt; request 注意： 是当前请求的request对象 12&lt;h5&gt;&#123;&#123;request.url&#125;&#125;&lt;/h5&gt;http://127.0.0.1:5000/index session flask中的session对象 12&#123;&#123; session.new&#125;&#125;False g 变量 在视图函数中设置的g变量的name属性的值，然后在模板中可以取出 由于g变量的特性，所以它也只能取到本次请求所携带的g变量的值 1&#123;&#123; g.name &#125;&#125; url_for() url_for 会根据传入的路由器函数名，返回改路由对应的URL，在模板中始终使用url_for() 就可以安全的修改路由绑定的URL，则不必担心模板中渲染出错的链接： 12345678## 显示 flask中方法函数对应的路由url地址&#123;&#123;url_for('home')&#125;&#125;&gt;&gt; /## 当有路由函数需要传入参数时，这是我们也需要传入参数就可以将完整url拼接出来&#123;&#123; url_for('user', userid=1)&#125;&#125;&gt;&gt; /user/1 流程控制 主要包含两个，（与django中的基本保持一致） 12 - if /else /endif- for /endfor 过滤器 常用的过滤器 过滤器名 说明 safe 渲染时不转义 capitalize 把值的首字母转换成大写，其他字母转换成小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格都去掉 striptags 渲染前把值中的所有的HTML标签都删掉 123## safe 过滤器 ,因为默认的安全机制会对html代码字符串进行转码。不让其正常进行渲染。&#123;&#123; index | safe &#125;&#125; 在jinja2 中， 过滤器是可以直接链式调用的1&#123;&#123;\"hello world \" | reverse | uppper &#125;&#125; 链式调用安装 github 可以当做静态资源仓库，调用的url为12345678910https://raw.githubusercontent.com/chenluzhong150394/img/master/1.png### 这是仓库的url，（可以查看内容的）https://raw.githubusercontent.com/chenluzhong150394 https://raw.githubusercontent.com/chenluzhong150394/img/master/11.png lsof -i:8080 linux 查看端口","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.clz.cloud/categories/Python/"}],"tags":[{"name":"flask框架","slug":"flask框架","permalink":"https://blog.clz.cloud/tags/flask框架/"}]},{"title":"Git的安装及常用操作","slug":"git","date":"2019-08-10T05:52:50.000Z","updated":"2022-03-28T08:51:04.754Z","comments":true,"path":"git.html","link":"","permalink":"https://blog.clz.cloud/git.html","excerpt":"","text":"安装gitLinux下安装yum安装 1yum -y install git test windows下安装官网地址： https://git-scm.com/download 下载到本地磁盘 安装 一路【next】就可以了 注意：openssl 一定选它 安装完成后，右击菜单栏，有如下菜单，表示安装完成 进入git bash选项 Git工作区、暂存区和版本库 git的使用本地使用git管理代码git项目仓库的本地搭建12345cd进入到自己希望存储代码的目录路径，并创建本地仓库.git新创建的本地仓库.git是个空仓库 cd 目录路径 git init gitdemo # 如果没有声明目录,则自动把当前目录作为git仓库 checkout 切换分支 pull 拉取远程git代码 branch -a 查看所有分支 管理远程git仓库删除远端git项目中的指定文件和目录 首先拉取远程git仓库 123456##如果本地仓库存在，则只需要pull 将远端git仓库与本地git仓库一直git pull##如果本地仓库不存在，则需要克隆clonegit clone https://gitee.com/chenluzhong/blog.git 使用git删除本地文件或目录 123456## 删除本地文件git rm &lt;file_name&gt;## 删除本地目录### -r 参数是递归删除的意思，如果目录是空的，就不用加这个参数也可以 git rm -r &lt;dir_name&gt; 提交代码到本地仓库 1git commit -m '删除某文件后的版本' 将本地仓库推送到远端 1git push &lt;base_url&gt; -u 本地仓库推送到码云首先码云仓库的地址是: https://gitee.com/chenluzhong/lufeiapi.git 设置全局配置(用户名和邮箱) 12git config --global user.name &apos;chenluzhong&apos;git config --global user.email &apos;18438128833@163.com&apos; 创建git仓库 1git init 提交本地的文件到暂存区 1git add . 将暂存区的内容提交到本地仓库中 1git commit -m &apos;这是第一个版本&apos; 然后关联远程仓库地址 1git remote add origin https://gitee.com/chenluzhong/lufeiapi.git 将本地的主分支与远程的分支进行关联 12git branch --set-upstream-to=origin/master mastergit pull orgin master 将本地仓库推送到远端仓库 1234## -u 参数指定唯一主机, master代表将推送到目标仓库的master主分支$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push -u origin master:master branch分支操作查看所有分支 查看本地分支 1git branch 查看远程分支 1git branch -a 创建分支 1git branch dev ##新建一个dev的本地分支 切换分支 1git checkout dev ## 切换到dev这个分支 删除分支 删除本地分支 1git branch -d dev ## 删除本地分支 删除远程分支 1git push origin --delete dev ## 删除远程仓库中dev分支","categories":[{"name":"Git","slug":"Git","permalink":"https://blog.clz.cloud/categories/Git/"}],"tags":[{"name":"git操作","slug":"git操作","permalink":"https://blog.clz.cloud/tags/git操作/"}]},{"title":"Shadowsocet配置多端口","slug":"shadowscoket 配置多端口 (需要配置防火墙)","date":"2019-08-10T05:52:50.000Z","updated":"2022-03-28T08:51:04.755Z","comments":true,"path":"shadowscoket 配置多端口 (需要配置防火墙).html","link":"","permalink":"https://blog.clz.cloud/shadowscoket 配置多端口 (需要配置防火墙).html","excerpt":"","text":"shadowscoket 配置多端口 (需要配置防火墙)先将要设置的端口在firewall防火墙放行 12firewall-cmd --zone=public --add-port=52300/tcp --permanent firewall-cmd --zone=public --add-port=52300/udp --permanent 查看firewall 开放的所有端口 1firewall-cmd --zone=public --list-ports 然后去将原来的shadowscoket配置文件进行备份 1cp /etc/shadowsocks.json /etc/shadowsocks.json.bak 然后打开配置文件替换成以下内容 1vim /etc/shadowsocks.json 1234567891011121314&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;&quot;52300&quot;:&quot;chenshuo003&quot;,&quot;52500&quot;:&quot;chenshuo003&quot;&#125;,&quot;obfs&quot;:&quot;plain&quot;,&quot;obfs_param&quot;:&quot;&quot;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false&#125; 然后重启shadowsocket服务并查看状态 1234# 重启服务/etc/init.d/shadowsocks restart## 查看服务状态/etc/init.d/shadowsocks status 重启锐速 12345## 重启锐速service serverSpeeder restart##查看锐速状态service serverSpeeder status 查看当前端口有多少IP链接(脚本有后台,需要手动禁止ip–hosts.deny) 使用netstat 命令 1netstat -anp | grep 52300 找到链接的ip,只要不是自己的,全部禁了 1234### 打开hosts.deny文件vim /etc/hosts.deny ### 将想要禁止的ip添加上去125.23.223.2 然后重启网卡服务,使hosts.deny文件生效 1systemctl restart network","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.clz.cloud/categories/Linux/"}],"tags":[{"name":"Shadowsocet","slug":"Shadowsocet","permalink":"https://blog.clz.cloud/tags/Shadowsocet/"}]},{"title":"数据库常用操作","slug":"l数据库","date":"2019-08-10T05:52:50.000Z","updated":"2022-03-28T08:51:04.755Z","comments":true,"path":"l数据库.html","link":"","permalink":"https://blog.clz.cloud/l数据库.html","excerpt":"","text":"数据库操作数据库的基本操作修改root密码1alter user root identifiled by password &apos;password&apos; MySQL修改用户的密码主要有两种方法：ALTER USER 和SET PASSWORD ALTER USER基本使用 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos;; 修改当前登录用户 1ALTER USER USER() IDENTIFIED BY &apos;123456&apos;; 使密码过期 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE; 使密码从不过期 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE NEVER; 按默认设置过期时间 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE DEFAULT; 指定过期间隔 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE INTERVAL 90 DAY; 在MySQL文档里，推荐使用ALTER USER修改用户密码 SET PASSWORD使用SET PASSWORD的password有两种： 使用默认加密 1SET PASSWORD FOR testuser = &apos;123456&apos; 使用PASSWORD()函数加密 1SET PASSWORD FOR testuser = PASSWORD(&quot;123456&quot;) 增删查改增加1、增加一个字段 1insert 2、增加一条记录 12 3、在多表关联的情况下，新增一条数据 12 删除1、删除一个字段 12 2、删除一条记录 12 3、删除多表中相关联的数据 12 更新1、更新一个字段名（在不改变原来数据的情况下） 12 2、更新一条数据中的某个字段的数据 12 3、在多表关联的情况下更新相关联的字段数据 12 查询1、单表查询（查询满足特定条件的所有数据） 12 2、使用左连接查询多表 12 修改1、给字段添加注释 12345#### 创建表的时候加注释create table test1(name char(32) comment&apos;字段注释&apos;) comment=‘表注释’；### 修改某个字段的属性并加上注释ALTER table table_name MODIFY `column_name` datetime DEFAULT NULL COMMENT &apos;这是字段的注释&apos; 2、给表加注释 1alter table table_name comment=&apos;这是表的注释&apos;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.clz.cloud/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/tags/linux/"}]},{"title":"celery中停止执行task","slug":"celery中停止执行task","date":"2019-07-06T09:26:24.000Z","updated":"2022-03-30T08:33:16.134Z","comments":true,"path":"celery中停止执行task.html","link":"","permalink":"https://blog.clz.cloud/celery中停止执行task.html","excerpt":"","text":"原因因为最近项目需求中需要提供对异步执行任务终止的功能，所以在寻找停止celery task任务的方法。这种需求以前没有碰到过，所以，只能求助于百度和google，但是找遍了资料，都没找到相关的能停止celery task任务的方法(网上找到的一个方法实测不能用，可能是celery版本的原因，我的项目目前使用的是celery 4.0.2) 解决过程由于网上找不到解决办法，于是只能自己想办法了。想到celery 管理工具flower里面好像有停止celery task的功能，于是去找flower的源码，找到接口的源码如下: 1234logger.info(\"Revoking task '%s'\", taskid)terminate = self.get_argument('terminate', default=False, type=bool)self.capp.control.revoke(taskid, terminate=terminate)self.write(dict(message=\"Revoked '%s'\" % taskid)) 核心代码是self.capp.control.revoke 想到去celery里面找寻revoke函数，发现有两处比较可疑，第一个是celery.worker.control.revoke，第二个是celery.app.control.Control.revoke，直觉来看，应该是第二个方法，但是第二个方法是在一个类里面的，要调用这个方法首先需要获取到celery app的实例，后来去celery 配置里面找，发现在init.py文件里面有__all__ = [&#39;celery_app&#39;]这么一句，于是找到突破点了，引用这个包就能获取到celery_app了。 12from test.ceyery_proj import celery_appcelery_app.control.revoke(task_id, terminate=True) 通过这个方法就能终止正在执行的task，至于task_id在执行任务的时候返回了，我将这个id存储在数据库中，这样就可以被拿来控制task的执行了。 写这篇文档的目的主要是帮助小伙伴们不要再踩这个坑了，也为celery提供一点文档补充吧。","categories":[{"name":"python","slug":"python","permalink":"https://blog.clz.cloud/categories/python/"}],"tags":[{"name":"celery","slug":"celery","permalink":"https://blog.clz.cloud/tags/celery/"},{"name":"python","slug":"python","permalink":"https://blog.clz.cloud/tags/python/"}]},{"title":"GO语言heap剖析","slug":"GO语言heap剖析","date":"2017-08-23T02:33:42.000Z","updated":"2022-03-28T08:51:04.753Z","comments":true,"path":"GO语言heap剖析.html","link":"","permalink":"https://blog.clz.cloud/GO语言heap剖析.html","excerpt":"","text":"heap使用在go语言的标准库container中，实现了三中数据类型：heap,list,ring，list在前面一篇文章中已经写了，现在要写的是heap（堆）的源码剖析。 首先，学会怎么使用heap，第一步当然是导入包了，代码如下： 123456package mainimport ( \"container/heap\" \"fmt\") 这个堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。源码里面只是实现了一个接口，它的定义如下： 12345type Interface interface &#123; sort.Interface Push(x interface&#123;&#125;) // add x as element Len() Pop() interface&#123;&#125; // remove and return element Len() - 1.&#125; 从这个接口可以看出，其继承了sort.Interface接口，那么sort.Interface的定义是什么呢？源码如下： 123456789type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 也就是说，我们要使用go标准库给我们提供的heap，那么必须自己实现这些接口定义的方法，需要实现的方法如下： Len() int Less(i, j int) bool Swap(i, j int) Push(x interface{}) Pop() interface{} 实现了这五个方法的数据类型才能使用go标准库给我们提供的heap，下面简单示例为定义一个IntHeap类型，并实现上面五个方法。 123456789101112131415161718192021type IntHeap []int // 定义一个类型func (h IntHeap) Len() int &#123; return len(h) &#125; // 绑定len方法,返回长度func (h IntHeap) Less(i, j int) bool &#123; // 绑定less方法 return h[i] &lt; h[j] // 如果h[i]&lt;h[j]生成的就是小根堆，如果h[i]&gt;h[j]生成的就是大根堆&#125;func (h IntHeap) Swap(i, j int) &#123; // 绑定swap方法，交换两个元素位置 h[i], h[j] = h[j], h[i]&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; // 绑定pop方法，从最后拿出一个元素并返回 old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; // 绑定push方法，插入新元素 *h = append(*h, x.(int))&#125; 针对IntHeap实现了这五个方法之后，我们就可以使用heap了，下面是具体使用方法： 1234567891011121314151617func main() &#123; h := &amp;IntHeap&#123;2, 1, 5, 6, 4, 3, 7, 9, 8, 0&#125; // 创建slice heap.Init(h) // 初始化heap fmt.Println(*h) fmt.Println(heap.Pop(h)) // 调用pop heap.Push(h, 6) // 调用push fmt.Println(*h) for len(*h) &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125;&#125;输出结果：[0 1 3 6 2 5 7 9 8 4]0[1 2 3 6 4 5 7 9 8 6]1 2 3 4 5 6 6 7 8 9 上面就是heap的使用了。 heap提供的方法heap提供的方法不多，具体如下： 123456h := &amp;IntHeap&#123;3, 8, 6&#125; // 创建IntHeap类型的原始数据func Init(h Interface) // 对heap进行初始化，生成小根堆（或大根堆）func Push(h Interface, x interface&#123;&#125;) // 往堆里面插入内容func Pop(h Interface) interface&#123;&#125; // 从堆顶pop出内容func Remove(h Interface, i int) interface&#123;&#125; // 从指定位置删除数据，并返回删除的数据func Fix(h Interface, i int) // 从i位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法 heap源码剖析heap的内部实现，是使用最小(最大)堆，索引排序从根节点开始，然后左子树，右子树的顺序方式。 内部实现的down和up分别表示对堆中的某个元素向下保证最小(最大)堆和向上保证最小(最大)堆。 当往堆中插入一个元素的时候，这个元素插入到最右子树的最后一个节点中，然后调用up向上保证最小(最大)堆。 当要从堆中推出一个元素的时候，先吧这个元素和右子树最后一个节点交换，然后弹出最后一个节点，然后对root调用down，向下保证最小(最大)堆。 好了，开始分析源码： 首先，在使用堆之前，必须调用它的Init方法，初始化堆，生成小根(大根)堆。Init方法源码如下: 123456789101112// A heap must be initialized before any of the heap operations// can be used. Init is idempotent with respect to the heap invariants// and may be called whenever the heap invariants may have been invalidated.// Its complexity is O(n) where n = h.Len().//func Init(h Interface) &#123; // heapify n := h.Len() // 获取数据的长度 for i := n/2 - 1; i &gt;= 0; i-- &#123; // 从长度的一半开始，一直到第0个数据，每个位置都调用down方法，down方法实现的功能是保证从该位置往下保证形成堆 down(h, i, n) &#125;&#125; 接下来看down的源码： 12345678910111213141516171819func down(h Interface, i0, n int) bool &#123; i := i0 // 中间变量，第一次存储的是需要保证往下需要形成堆的节点位置 for &#123; // 死循环 j1 := 2*i + 1 // i节点的左子孩子 if j1 &gt;= n || j1 &lt; 0 &#123; // j1 &lt; 0 after int overflow // 保证其左子孩子没有越界 break &#125; j := j1 // left child // 中间变量j先赋值为左子孩子，之后j将被赋值为左右子孩子中最小（大）的一个孩子的位置 if j2 := j1 + 1; j2 &lt; n &amp;&amp; !h.Less(j1, j2) &#123; j = j2 // = 2*i + 2 // right child &#125; // 这之后，j被赋值为两个孩子中的最小（大）孩子的位置（最小或最大由Less中定义的决定） if !h.Less(j, i) &#123; break &#125; // 若j大于（小于）i，则终止循环 h.Swap(i, j) // 否则交换i和j位置的值 i = j // 令i=j，继续循环，保证j位置的子数是堆结构 &#125; return i &gt; i0&#125; 这是建立堆的核心代码，其实，down并不能完全保证从某个节点往下每个节点都能保持堆的特性，只能保证某个节点的值如果不满足堆的性质，则将该值与其孩子交换，直到该值放到适合的位置，保证该值及其两个子孩子满足堆的性质。 但是，如果是通过Init循环调用down将能保证初始化后所有的节点都保持堆的特性，这是因为循环开始的i := n/2 - 1的取值位置，将会取到最大的一个拥有孩子节点的节点，并且该节点最多只有两个孩子，并且其孩子节点是叶子节点，从该节点往前每个节点如果都能保证down的特性，则整个列表也就符合了堆的性质了。 同样，有down就有up，up保证的是某个节点如果向上没有保证堆的性质，则将其与父节点进行交换，直到该节点放到某个特定位置保证了堆的性质。代码如下： 12345678910func up(h Interface, j int) &#123; for &#123; // 死循环 i := (j - 1) / 2 // parent // j节点的父节点 if i == j || !h.Less(j, i) &#123; // 如果越界，或者满足堆的条件，则结束循环 break &#125; h.Swap(i, j) // 否则将该节点和父节点交换 j = i // 对父节点继续进行检查直到根节点 &#125;&#125; 以上两个方法就是最核心的方法了，所有暴露出来的方法无非就是对这两个方法进行的封装。我们来看看以下这些方法的源码： 123456789101112131415161718192021222324252627func Push(h Interface, x interface&#123;&#125;) &#123; h.Push(x) // 将新插入进来的节点放到最后 up(h, h.Len()-1) // 确保新插进来的节点网上能保证堆结构&#125;func Pop(h Interface) interface&#123;&#125; &#123; n := h.Len() - 1 // 把最后一个节点和第一个节点进行交换，之后，从根节点开始重新保证堆结构，最后把最后那个节点数据丢出并返回 h.Swap(0, n) down(h, 0, n) return h.Pop()&#125;func Remove(h Interface, i int) interface&#123;&#125; &#123; n := h.Len() - 1 pop只是remove的特殊情况，remove是把i位置的节点和最后一个节点进行交换，之后保证从i节点往下及往上都保证堆结构，最后把最后一个节点的数据丢出并返回 if n != i &#123; h.Swap(i, n) down(h, i, n) up(h, i) &#125; return h.Pop()&#125;func Fix(h Interface, i int) &#123; if !down(h, i, h.Len()) &#123; // i节点的数值发生改变后，需要保证堆的再平衡，先调用down保证该节点下面的堆结构，如果有位置交换，则需要保证该节点往上的堆结构，否则就不需要往上保证堆结构，一个小小的优化 up(h, i) &#125;&#125; 以上就是go里面的heap所有的源码了，我也就不贴出完整版源码了，以上理解全部基于个人的理解，如有不当之处，还望批评指正。 利用heap实现优先级队列既然用到了heap，那就用heap实现一个优先级队列吧，这个功能是很好的一个功能。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( \"container/heap\" \"fmt\")type Item struct &#123; value string // 优先级队列中的数据，可以是任意类型，这里使用string priority int // 优先级队列中节点的优先级 index int // index是该节点在堆中的位置&#125;// 优先级队列需要实现heap的interfacetype PriorityQueue []*Item// 绑定Len方法func (pq PriorityQueue) Len() int &#123; return len(pq)&#125;// 绑定Less方法，这里用的是小于号，生成的是小根堆func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].priority &lt; pq[j].priority&#125;// 绑定swap方法func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i] pq[i].index, pq[j].index = i, j&#125;// 绑定put方法，将index置为-1是为了标识该数据已经出了优先级队列了func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) item := old[n-1] *pq = old[0 : n-1] item.index = -1 return item&#125;// 绑定push方法func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item)&#125;// 更新修改了优先级和值的item在优先级队列中的位置func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123; item.value = value item.priority = priority heap.Fix(pq, item.index)&#125;func main() &#123; // 创建节点并设计他们的优先级 items := map[string]int&#123;\"二毛\": 5, \"张三\": 3, \"狗蛋\": 9&#125; i := 0 pq := make(PriorityQueue, len(items)) // 创建优先级队列，并初始化 for k, v := range items &#123; // 将节点放到优先级队列中 pq[i] = &amp;Item&#123; value: k, priority: v, index: i&#125; i++ &#125; heap.Init(&amp;pq) // 初始化堆 item := &amp;Item&#123; // 创建一个item value: \"李四\", priority: 1, &#125; heap.Push(&amp;pq, item) // 入优先级队列 pq.update(item, item.value, 6) // 更新item的优先级 for len(pq) &gt; 0 &#123; item := heap.Pop(&amp;pq).(*Item) fmt.Printf(\"%.2d:%s index:%.2d\\n\", item.priority, item.value, item.index) &#125;&#125;输出结果：03:张三 index:-0105:二毛 index:-0106:李四 index:-0109:狗蛋 index:-01","categories":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/tags/golang/"},{"name":"heap","slug":"heap","permalink":"https://blog.clz.cloud/tags/heap/"}]},{"title":"GO语言list剖析","slug":"GO语言list剖析","date":"2017-08-23T02:33:42.000Z","updated":"2022-03-28T08:51:04.754Z","comments":true,"path":"GO语言list剖析.html","link":"","permalink":"https://blog.clz.cloud/GO语言list剖析.html","excerpt":"","text":"使用方法在GO语言的标准库中，提供了一个container包，这个包中提供了三种数据类型，就是heap,list和ring，本节要讲的是list的使用以及源码剖析。要使用GO提供的list链表，则首先需要导入list包，如下所示： 1234package mainimport( \"container/list\") 导入包之后，需要了解list中定义了两种数据类型，Element和List，定义如下： 1234567891011121314151617181920// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125; Element里面定义了两个Element类型的指针next, prev以及List类型的指针list, Value用来存储值，List里面定义了一个Element作为链表的Root，len作为链表的长度。 import之后，就可以使用链表了： 12345678910func main() &#123; list_test:=list.New() // 创建list对象 list_test.PushBack(\"123\") // 往List队列尾部插入数据 list_test.PushBack(\"456\") list_test.PushBack(\"789\") fmt.Println(list_test.Len()) // 输出list长度 fmt.Println(list_test.Front()) // 输出list第一个元素 fmt.Println(list_test.Front().Next()) // 输出list第一个元素的下一个元素 fmt.Println(list_test.Front().Next().Next()) // 输出list第三个元素&#125; list提供的方法list提供的方法如下： 1234567891011121314151617181920type Element func (e *Element) Next() *Element func (e *Element) Prev() *Elementtype List func New() *List func (l *List) Back() *Element // 返回最后一个元素 func (l *List) Front() *Element // 返回第一个元素 func (l *List) Init() *List // 链表初始化 func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element // 在某个元素前插入 func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element // 在某个元素后插入 func (l *List) Len() int // 返回链表长度 func (l *List) MoveAfter(e, mark *Element) // 把e元素移动到mark之后 func (l *List) MoveBefore(e, mark *Element) // 把e元素移动到mark之前 func (l *List) MoveToBack(e *Element) // 把e元素移动到队列最后 func (l *List) MoveToFront(e *Element) // 把e元素移动到队列最头部 func (l *List) PushBack(v interface&#123;&#125;) *Element // 在队列最后插入元素 func (l *List) PushBackList(other *List) // 在队列最后插入接上新队列 func (l *List) PushFront(v interface&#123;&#125;) *Element // 在队列头部插入元素 func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列 func (l *List) Remove(e *Element) interface&#123;&#125; // 删除某个元素 源码剖析首先，使用list.New()方法，返回的是一个List对象的指针，源码New() *List &#123; return new(List).Init() &#125;```并执行了List对象的Init()方法对list进行初始化，初始化root的prev和next指针以及list的长度。1234567之后调用list_test.PushBack(&quot;123&quot;)在队列尾部插入元素123，源码如下：```gofunc (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125; 调用lazyInit(),如果链表没有初始化，则先初始化一遍，之后，调用list的insertValue方法，insertValue方法初始化节点之后，调用insert方法进行插入链表。 123func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125; 整篇文章最精髓的地方就在insert方法中了，源码如下： 12345678910func (l *List) insert(e, at *Element) *Element &#123; n := at.next // 用中间变量n保存at节点的next指针 at.next = e // at节点的next指向要插入的节点 e.prev = at // 要插入的节点e的prev指向at节点 e.next = n // e的next节点指向中间变量n保存的指针 n.prev = e // at节点的下一个节点的prev指向e节点 e.list = l // e节点的list指向链表的root节点 l.len++ // 链表的长度加一 return e // 返回刚插入节点的指针&#125; 这里的链表结构是双向链表，并且在root节点的prev指针指向了链表的结尾，链表结尾的next指针也指向了root节点，这样，其实形成了一个环形结构，如果是向链表的尾部插入新数据，则将root.prev传递给insert方法的at参数，如果是向头部插入，则将root传递给insert方法的at参数。 这样做的好处是显而易见的，那就是从链表的尾部插入数据，将不需要遍历一遍链表，而只需要将root节点的prev传递给insert方法中就可以了，大大节省了从尾部插入节点的时间。这段代码我看了很久，觉得这个包中最精髓的地方也就在这了，这也是这篇文章诞生的原因。 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package list implements a doubly linked list.//// To iterate over a list (where l is a *List):// for e := l.Front(); e != nil; e = e.Next() &#123;// // do something with e.Value// &#125;//package list// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;// Next returns the next list element or nil.func (e *Element) Next() *Element &#123; if p := e.next; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// Prev returns the previous list element or nil.func (e *Element) Prev() *Element &#123; if p := e.prev; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125;// Init initializes or clears list l.func (l *List) Init() *List &#123; l.root.next = &amp;l.root l.root.prev = &amp;l.root l.len = 0 return l&#125;// New returns an initialized list.func New() *List &#123; return new(List).Init() &#125;// Len returns the number of elements of list l.// The complexity is O(1).func (l *List) Len() int &#123; return l.len &#125;// Front returns the first element of list l or nil.func (l *List) Front() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.next&#125;// Back returns the last element of list l or nil.func (l *List) Back() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.prev&#125;// lazyInit lazily initializes a zero List value.func (l *List) lazyInit() &#123; if l.root.next == nil &#123; l.Init() &#125;&#125;// insert inserts e after at, increments l.len, and returns e.func (l *List) insert(e, at *Element) *Element &#123; n := at.next at.next = e e.prev = at e.next = n n.prev = e e.list = l l.len++ return e&#125;// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125;// remove removes e from its list, decrements l.len, and returns e.func (l *List) remove(e *Element) *Element &#123; e.prev.next = e.next e.next.prev = e.prev e.next = nil // avoid memory leaks e.prev = nil // avoid memory leaks e.list = nil l.len-- return e&#125;// Remove removes e from l if e is an element of list l.// It returns the element value e.Value.func (l *List) Remove(e *Element) interface&#123;&#125; &#123; if e.list == l &#123; // if e.list == l, l must have been initialized when e was inserted // in l or l == nil (e is a zero Element) and l.remove will crash l.remove(e) &#125; return e.Value&#125;// PushFront inserts a new element e with value v at the front of list l and returns e.func (l *List) PushFront(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, &amp;l.root)&#125;// PushBack inserts a new element e with value v at the back of list l and returns e.func (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125;// InsertBefore inserts a new element e with value v immediately before mark and returns e.// If mark is not an element of l, the list is not modified.func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark.prev)&#125;// InsertAfter inserts a new element e with value v immediately after mark and returns e.// If mark is not an element of l, the list is not modified.func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark)&#125;// MoveToFront moves element e to the front of list l.// If e is not an element of l, the list is not modified.func (l *List) MoveToFront(e *Element) &#123; if e.list != l || l.root.next == e &#123; return &#125; // see comment in List.Remove about initialization of l l.insert(l.remove(e), &amp;l.root)&#125;// MoveToBack moves element e to the back of list l.// If e is not an element of l, the list is not modified.func (l *List) MoveToBack(e *Element) &#123; if e.list != l || l.root.prev == e &#123; return &#125; // see comment in List.Remove about initialization of l l.insert(l.remove(e), l.root.prev)&#125;// MoveBefore moves element e to its new position before mark.// If e or mark is not an element of l, or e == mark, the list is not modified.func (l *List) MoveBefore(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.insert(l.remove(e), mark.prev)&#125;// MoveAfter moves element e to its new position after mark.// If e or mark is not an element of l, or e == mark, the list is not modified.func (l *List) MoveAfter(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.insert(l.remove(e), mark)&#125;// PushBackList inserts a copy of an other list at the back of list l.// The lists l and other may be the same.func (l *List) PushBackList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Front(); i &gt; 0; i, e = i-1, e.Next() &#123; l.insertValue(e.Value, l.root.prev) &#125;&#125;// PushFrontList inserts a copy of an other list at the front of list l.// The lists l and other may be the same.func (l *List) PushFrontList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Back(); i &gt; 0; i, e = i-1, e.Prev() &#123; l.insertValue(e.Value, &amp;l.root) &#125;&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/tags/golang/"},{"name":"list","slug":"list","permalink":"https://blog.clz.cloud/tags/list/"}]},{"title":"centos 7 安装mariadb","slug":"centos 7 安装mariadb","date":"2017-08-23T02:33:42.000Z","updated":"2022-03-28T08:51:04.754Z","comments":true,"path":"centos 7 安装mariadb.html","link":"","permalink":"https://blog.clz.cloud/centos 7 安装mariadb.html","excerpt":"","text":"@TOC 序言听说Oracle 公司要对mysql 进行推出收费版本了,一般收费版本肯定要比免费使用的版本功能更强大些,所以我感觉说不定要对免费版本限制功能了,那这样的话,还不如开始使用MySQL原作者推出的免费版–mariadb其实就一点,跟centos一个样 免费跟收费的区别,所以一般公司用的还大多是centos ,为啥 不收费呀! ,而且centos就是rhel是一模一样的,唯一的差别改了一个图标而已,t同理,mysql跟mariadb底层是通用的,mariadb兼容MySQL,而且在MySQL的基础上增加了很多功能,更为强大好用 &nbsp; 由于官网的MariaDB版本要比阿里云的版本要高，所以我们应该优先使用官方的版本 注意: 在centos7 中默认使用的数据库已经切换成了mariadb,所以我们通过yum安装的时候,直接安装MySQL就行 首先 添加MariaDB yum仓库 1、首先在 RHEL/CentOS 和 Fedora 操作系统中添加 MariaDB 的 YUM 配置文件 MariaDB.repo 文件。12# 编辑创建mariadb.repo仓库文件vi /etc/yum.repos.d/MariaDB.repo 2、添加repo仓库配置12345[mariadb]name=MariaDBbaseurl=http://yum.mariadb.org/10.1/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1 3、当 MariaDB 仓库地址添加好后，你可以通过下面的一行命令轻松安装 MariaDB。1yum install MariaDB-server MariaDB-client -y 4、如果官方的版本下载太慢，我们就直接使用阿里云的比较低的版本也可以(1) 删除或者重命名刚才创建的Mariadb.repo文件 12cd /etc/yum.repos.dmv Mariadb.repo Mariadb.repo.bak (2) 然后一条命令安装Mariadb 1yum install mariadb-server mariadb -y 5 启动mariadb命令mariadb数据库的相关命令是： 1234systemctl start mariadb # 启动MariaDBsystemctl stop mariadb # 停止MariaDBsystemctl restart mariadb # 重启MariaDBsystemctl enable mariadb # 设置开机启动 6 初始化mysql1mysql_secure_installation 7 使用mysql命令进入数据库1mysql -u root -p 8 mysql基本操作12345671 创建数据库2 创建表create table qishitb (id int, name char(11));3 插入数据insert into qishitb values(1, \"陈鹏\");4 查看数据select * from qishitb; 12345查看数据库的信息\\s查看表的编码信息show create table qishitb 9 解决中文乱码问题(1) 修改配置文件 1vim /etc/my.cnf (2) 添加以下配置文件(如图) 12345678[mysqld]character-set-server=utf8collation-server=utf8_general_cilog-error=/var/log/mysqld.log[client]default-character-set=utf8[mysql]default-character-set=utf8 (3) 重启数据库 1systemctl restart mariadb","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.clz.cloud/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/tags/linux/"}]},{"title":"centos 7 安装mariadb2222","slug":"centos 7 安装mariadb copy","date":"2017-08-23T02:33:42.000Z","updated":"2022-03-29T10:07:42.863Z","comments":true,"path":"centos 7 安装mariadb copy.html","link":"","permalink":"https://blog.clz.cloud/centos 7 安装mariadb copy.html","excerpt":"","text":"@TOC 序言听说Oracle 公司要对mysql 进行推出收费版本了,一般收费版本肯定要比免费使用的版本功能更强大些,所以我感觉说不定要对免费版本限制功能了,那这样的话,还不如开始使用MySQL原作者推出的免费版–mariadb其实就一点,跟centos一个样 免费跟收费的区别,所以一般公司用的还大多是centos ,为啥 不收费呀! ,而且centos就是rhel是一模一样的,唯一的差别改了一个图标而已,t同理,mysql跟mariadb底层是通用的,mariadb兼容MySQL,而且在MySQL的基础上增加了很多功能,更为强大好用 &nbsp; 由于官网的MariaDB版本要比阿里云的版本要高，所以我们应该优先使用官方的版本 注意: 在centos7 中默认使用的数据库已经切换成了mariadb,所以我们通过yum安装的时候,直接安装MySQL就行 首先 添加MariaDB yum仓库 1、首先在 RHEL/CentOS 和 Fedora 操作系统中添加 MariaDB 的 YUM 配置文件 MariaDB.repo 文件。12# 编辑创建mariadb.repo仓库文件vi /etc/yum.repos.d/MariaDB.repo 2、添加repo仓库配置12345[mariadb]name=MariaDBbaseurl=http://yum.mariadb.org/10.1/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1 3、当 MariaDB 仓库地址添加好后，你可以通过下面的一行命令轻松安装 MariaDB。1yum install MariaDB-server MariaDB-client -y 4、如果官方的版本下载太慢，我们就直接使用阿里云的比较低的版本也可以(1) 删除或者重命名刚才创建的Mariadb.repo文件 12cd /etc/yum.repos.dmv Mariadb.repo Mariadb.repo.bak (2) 然后一条命令安装Mariadb 1yum install mariadb-server mariadb -y 5 启动mariadb命令mariadb数据库的相关命令是： 1234systemctl start mariadb # 启动MariaDBsystemctl stop mariadb # 停止MariaDBsystemctl restart mariadb # 重启MariaDBsystemctl enable mariadb # 设置开机启动 6 初始化mysql1mysql_secure_installation 7 使用mysql命令进入数据库1mysql -u root -p 8 mysql基本操作12345671 创建数据库2 创建表create table qishitb (id int, name char(11));3 插入数据insert into qishitb values(1, \"陈鹏\");4 查看数据select * from qishitb; 12345查看数据库的信息\\s查看表的编码信息show create table qishitb 9 解决中文乱码问题(1) 修改配置文件 1vim /etc/my.cnf (2) 添加以下配置文件(如图) 12345678[mysqld]character-set-server=utf8collation-server=utf8_general_cilog-error=/var/log/mysqld.log[client]default-character-set=utf8[mysql]default-character-set=utf8 (3) 重启数据库 1systemctl restart mariadb","categories":[{"name":"数据库2","slug":"数据库2","permalink":"https://blog.clz.cloud/categories/数据库2/"}],"tags":[{"name":"linux2","slug":"linux2","permalink":"https://blog.clz.cloud/tags/linux2/"}]}],"categories":[{"name":"GO","slug":"GO","permalink":"https://blog.clz.cloud/categories/GO/"},{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/categories/golang/"},{"name":"Python","slug":"Python","permalink":"https://blog.clz.cloud/categories/Python/"},{"name":"Git","slug":"Git","permalink":"https://blog.clz.cloud/categories/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.clz.cloud/categories/Linux/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.clz.cloud/categories/数据库/"},{"name":"python","slug":"python","permalink":"https://blog.clz.cloud/categories/python/"},{"name":"数据库2","slug":"数据库2","permalink":"https://blog.clz.cloud/categories/数据库2/"}],"tags":[{"name":"c l z","slug":"c-l-z","permalink":"https://blog.clz.cloud/tags/c-l-z/"},{"name":"golang","slug":"golang","permalink":"https://blog.clz.cloud/tags/golang/"},{"name":"go","slug":"go","permalink":"https://blog.clz.cloud/tags/go/"},{"name":"flask框架","slug":"flask框架","permalink":"https://blog.clz.cloud/tags/flask框架/"},{"name":"git操作","slug":"git操作","permalink":"https://blog.clz.cloud/tags/git操作/"},{"name":"Shadowsocet","slug":"Shadowsocet","permalink":"https://blog.clz.cloud/tags/Shadowsocet/"},{"name":"linux","slug":"linux","permalink":"https://blog.clz.cloud/tags/linux/"},{"name":"celery","slug":"celery","permalink":"https://blog.clz.cloud/tags/celery/"},{"name":"python","slug":"python","permalink":"https://blog.clz.cloud/tags/python/"},{"name":"heap","slug":"heap","permalink":"https://blog.clz.cloud/tags/heap/"},{"name":"list","slug":"list","permalink":"https://blog.clz.cloud/tags/list/"},{"name":"linux2","slug":"linux2","permalink":"https://blog.clz.cloud/tags/linux2/"}]}